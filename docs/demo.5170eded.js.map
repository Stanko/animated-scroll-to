{"version":3,"sources":["src/animated-scroll-to.ts","demo.js"],"names":["window","animateScrollTo"],"mappings":"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","file":"demo.5170eded.js","sourceRoot":"..","sourcesContent":["export type TCoords = [number | null | undefined, number | null | undefined];\n\nexport interface IOptions {\n  cancelOnUserAction?: boolean\n  easing?: (t: number) => number\n  elementToScroll?: Element | Window\n  horizontalOffset?: number\n  maxDuration?: number\n  minDuration?: number\n  passive?: boolean\n  speed?: number\n  verticalOffset?: number\n}\n\n// --------- HELPERS\n\nfunction getElementOffset(el) {\n  let top = 0;\n  let left = 0;\n  let element = el;\n\n  // Loop through the DOM tree\n  // and add it's parent's offset to get page offset\n  do {\n    top += element.offsetTop || 0;\n    left += element.offsetLeft || 0;\n    element = element.offsetParent;\n  } while (element);\n\n  return {\n    top,\n    left,\n  };\n}\n\n// --------- SCROLL INTERFACES\n\n// ScrollDomElement and ScrollWindow have identical interfaces\n\nclass ScrollDomElement {\n  element: Element\n\n  constructor(element: Element) {\n    this.element = element;\n  }\n\n  getHorizontalScroll(): number {\n    return this.element.scrollLeft;\n  }\n\n  getVerticalScroll(): number {\n    return this.element.scrollTop;\n  }\n\n  getMaxHorizontalScroll(): number {\n    return this.element.scrollWidth - this.element.clientWidth;\n  }\n\n  getMaxVerticalScroll(): number {\n    return this.element.scrollHeight - this.element.clientHeight;\n  }\n\n  getHorizontalElementScrollOffset(elementToScrollTo: Element, elementToScroll: Element): number {\n    return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;\n  }\n\n  getVerticalElementScrollOffset(elementToScrollTo: Element, elementToScroll: Element): number {\n    return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;\n  }\n\n  scrollTo(x: number, y: number) {\n    this.element.scrollLeft = x;\n    this.element.scrollTop = y;\n  }\n}\n\nclass ScrollWindow {\n  getHorizontalScroll(): number {\n    return window.scrollX || document.documentElement.scrollLeft;\n  }\n\n  getVerticalScroll(): number {\n    return window.scrollY || document.documentElement.scrollTop;\n  }\n\n  getMaxHorizontalScroll(): number {\n    return Math.max(\n      document.body.scrollWidth, document.documentElement.scrollWidth,\n      document.body.offsetWidth, document.documentElement.offsetWidth,\n      document.body.clientWidth, document.documentElement.clientWidth\n    ) - window.innerWidth;\n  }\n\n  getMaxVerticalScroll(): number {\n    return Math.max(\n      document.body.scrollHeight, document.documentElement.scrollHeight,\n      document.body.offsetHeight, document.documentElement.offsetHeight,\n      document.body.clientHeight, document.documentElement.clientHeight\n    ) - window.innerHeight;\n  }\n\n  getHorizontalElementScrollOffset(elementToScrollTo: Element): number {\n    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n    return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n  }\n\n  getVerticalElementScrollOffset(elementToScrollTo: Element): number {\n    const scrollTop = window.scrollY || document.documentElement.scrollTop;\n    return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n  }\n\n  scrollTo(x: number, y: number) {\n    window.scrollTo(x, y)\n  }\n}\n\n// --------- KEEPING TRACK OF ACTIVE ANIMATIONS\n\nconst activeAnimations = {\n  elements: [],\n  cancelMethods: [],\n\n  add: (element: Element | Window, cancelAnimation: () => void) => {\n    activeAnimations.elements.push(element);\n    activeAnimations.cancelMethods.push(cancelAnimation);\n  },\n  remove: (element: Element | Window, shouldStop: boolean = true) => {\n    const index = activeAnimations.elements.indexOf(element);\n\n    if (index > -1) {\n      // Stop animation\n      if (shouldStop) {\n        activeAnimations.cancelMethods[index]();\n      }\n      // Remove it\n      activeAnimations.elements.splice(index, 1);\n      activeAnimations.cancelMethods.splice(index, 1);\n    }\n  }\n};\n\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\n\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n\n// --------- ANIMATE SCROLL TO\n\nconst defaultOptions: IOptions = {\n  cancelOnUserAction: true,\n  easing: t => (--t) * t * t + 1, // easeOutCubic\n  elementToScroll: WINDOW_EXISTS ? window : null, // Check for server side rendering\n  horizontalOffset: 0,\n  maxDuration: 3000,\n  minDuration: 250,\n  speed: 500,\n  verticalOffset: 0,\n};\n\nasync function animateScrollTo(y: number, userOptions?: IOptions): Promise<boolean>;\nasync function animateScrollTo(coords: TCoords, userOptions?: IOptions): Promise<boolean>;\nasync function animateScrollTo(scrollToElement: Element, userOptions?: IOptions): Promise<boolean>;\nasync function animateScrollTo(\n  numberOrCoordsOrElement: number | TCoords | Element,\n  userOptions: IOptions = {}\n): Promise<boolean> {\n  // Check for server rendering\n  if (!WINDOW_EXISTS) {\n    // @ts-ignore\n    // If it still gets called on server, return Promise for API consistency\n    return new Promise((resolve: (hasScrolledToPosition: boolean) => void) => {\n      resolve(false); // Returning false on server\n    });\n  } else if (!(window as any).Promise) {\n    throw (\n      'Browser doesn\\'t support Promises, and animated-scroll-to depends on it, please provide a polyfill.'\n    );\n  }\n\n  let x: number | null;\n  let y: number | null;\n  let scrollToElement: Element;\n  let options: IOptions = {\n    ...defaultOptions,\n    ...userOptions,\n  };\n\n  const isWindow = options.elementToScroll === window;\n  const isElement = !!(options.elementToScroll as Element).nodeName;\n\n  if (!isWindow && !isElement) {\n    throw (\n      'Element to scroll needs to be either window or DOM element.'\n    );\n  }\n\n  // Check for \"scroll-behavior: smooth\" as it can break the animation\n  // https://github.com/Stanko/animated-scroll-to/issues/55\n  const scrollBehaviorElement: Element = isWindow ? document.documentElement : (options.elementToScroll as Element);\n  const scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n\n  if (scrollBehavior === 'smooth') {\n    console.warn(`${scrollBehaviorElement.tagName} has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations`);\n  }\n\n  // Select the correct scrolling interface\n  const elementToScroll = isWindow ?\n    new ScrollWindow() :\n    new ScrollDomElement(options.elementToScroll as Element);\n\n  if (numberOrCoordsOrElement instanceof Element) {\n    scrollToElement = numberOrCoordsOrElement;\n\n    // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n    if (\n      isElement &&\n      (\n        !(options.elementToScroll as Element).contains(scrollToElement) ||\n        (options.elementToScroll as Element).isSameNode(scrollToElement)\n      )\n    ) {\n      throw (\n        'options.elementToScroll has to be a parent of scrollToElement'\n      );\n    }\n\n    x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, (options.elementToScroll as Element));\n    y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, (options.elementToScroll as Element));\n  } else if (typeof numberOrCoordsOrElement === 'number') {\n    x = elementToScroll.getHorizontalScroll();\n    y = numberOrCoordsOrElement;\n  } else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {\n    x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];\n    y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];\n  } else {\n    // ERROR\n    throw (\n      'Wrong function signature. Check documentation.\\n' +\n      'Available method signatures are:\\n' +\n      '  animateScrollTo(y:number, options)\\n' +\n      '  animateScrollTo([x:number | null, y:number | null], options)\\n' +\n      '  animateScrollTo(scrollToElement:Element, options)'\n    );\n  }\n\n  // Add offsets\n  x += options.horizontalOffset;\n  y += options.verticalOffset;\n\n\n  // Horizontal scroll distance\n  const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n  const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n\n  // If user specified scroll position is greater than maximum available scroll\n  if (x > maxHorizontalScroll) {\n    x = maxHorizontalScroll;\n  }\n\n  // Calculate distance to scroll\n  const horizontalDistanceToScroll = x - initialHorizontalScroll;\n\n  // Vertical scroll distance distance\n  const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n  const initialVerticalScroll = elementToScroll.getVerticalScroll();\n\n  // If user specified scroll position is greater than maximum available scroll\n  if (y > maxVerticalScroll) {\n    y = maxVerticalScroll;\n  }\n\n  // Calculate distance to scroll\n  const verticalDistanceToScroll = y - initialVerticalScroll;\n\n  // Calculate duration of the scroll\n  const horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));\n  const verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));\n\n  let duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration;\n\n  // Set minimum and maximum duration\n  if (duration < options.minDuration) {\n    duration = options.minDuration;\n  } else if (duration > options.maxDuration) {\n    duration = options.maxDuration;\n  }\n\n  // @ts-ignore\n  return new Promise((resolve: (hasScrolledToPosition: boolean) => void, reject) => {\n    // Scroll is already in place, nothing to do\n    if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n      // Resolve promise with a boolean hasScrolledToPosition set to true\n      resolve(true);\n    }\n\n    // Cancel existing animation if it is already running on the same element\n    activeAnimations.remove(options.elementToScroll, true);\n\n    // To cancel animation we have to store request animation frame ID \n    let requestID;\n\n    // Cancel animation handler\n    const cancelAnimation = () => {\n      removeListeners();\n      cancelAnimationFrame(requestID);\n\n      // Resolve promise with a boolean hasScrolledToPosition set to false\n      resolve(false);\n    };\n\n    // Registering animation so it can be canceled if function\n    // gets called again on the same element\n    activeAnimations.add(options.elementToScroll, cancelAnimation);\n\n    // Prevent user actions handler\n    const preventDefaultHandler = e => e.preventDefault();\n\n    const handler = options.cancelOnUserAction ?\n      cancelAnimation :\n      preventDefaultHandler;\n\n    // If animation is not cancelable by the user, we can't use passive events\n    const eventOptions: any = options.cancelOnUserAction ?\n      { passive: true } :\n      { passive: false };\n\n    const events = [\n      'wheel',\n      'touchstart',\n      'keydown',\n      'mousedown',\n    ];\n\n    // Function to remove listeners after animation is finished\n    const removeListeners = () => {\n      events.forEach(eventName => {\n        options.elementToScroll.removeEventListener(eventName, handler, eventOptions);\n      });\n    };\n\n    // Add listeners\n    events.forEach(eventName => {\n      options.elementToScroll.addEventListener(eventName, handler, eventOptions);\n    });\n\n    // Animation\n    const startingTime = Date.now();\n\n    const step = () => {\n      var timeDiff = Date.now() - startingTime;\n      var t = timeDiff / duration;\n\n      const horizontalScrollPosition = Math.round(initialHorizontalScroll + (horizontalDistanceToScroll * options.easing(t)));\n      const verticalScrollPosition = Math.round(initialVerticalScroll + (verticalDistanceToScroll * options.easing(t)));\n\n      if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n        // If scroll didn't reach desired position or time is not elapsed\n        // Scroll to a new position\n        elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n\n        // And request a new step\n        requestID = requestAnimationFrame(step);\n      } else {\n        // If the time elapsed or we reached the desired offset\n        // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n        // Clear animation frame to be sure\n        elementToScroll.scrollTo(x, y);\n\n        cancelAnimationFrame(requestID);\n\n        // Remove listeners\n        removeListeners();\n\n        // Remove animation from the active animations coordinator\n        activeAnimations.remove(options.elementToScroll, false);\n\n        // Resolve promise with a boolean hasScrolledToPosition set to true\n        resolve(true);\n      }\n    };\n\n    // Start animating scroll\n    requestID = requestAnimationFrame(step);\n  });\n}\n\nexport default animateScrollTo;\n","import animateScrollTo from './src/animated-scroll-to';\n\nwindow.animateScrollTo = animateScrollTo;;\n"]}