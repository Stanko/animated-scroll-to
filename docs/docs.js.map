{
  "version": 3,
  "sources": ["../src/index.ts", "docs.ts"],
  "sourcesContent": ["export type TCoords = [number | null | undefined, number | null | undefined];\n\nexport interface IUserOptions {\n  cancelOnUserAction?: boolean;\n  easing?: (t: number) => number;\n  elementToScroll?: Element | Window;\n  horizontalOffset?: number;\n  maxDuration?: number;\n  minDuration?: number;\n  speed?: number;\n  verticalOffset?: number;\n}\n\nexport interface IOptions {\n  cancelOnUserAction: boolean;\n  easing: (t: number) => number;\n  elementToScroll: Element | Window | null;\n  horizontalOffset: number;\n  maxDuration: number;\n  minDuration: number;\n  speed: number;\n  verticalOffset: number;\n}\n\n// --------- HELPERS\n\nfunction getElementOffset(el: Element) {\n  let top = 0;\n  let left = 0;\n  let element: HTMLElement = el as HTMLElement;\n\n  // Loop through the DOM tree\n  // and add it's parent's offset to get page offset\n  do {\n    top += element.offsetTop || 0;\n    left += element.offsetLeft || 0;\n    element = element.offsetParent as HTMLElement;\n  } while (element);\n\n  return {\n    top,\n    left,\n  };\n}\n\n// --------- SCROLL INTERFACES\n\n// ScrollDomElement and ScrollWindow have identical interfaces\n\nclass ScrollDomElement {\n  element: Element;\n\n  constructor(element: Element) {\n    this.element = element;\n  }\n\n  getHorizontalScroll(): number {\n    return this.element.scrollLeft;\n  }\n\n  getVerticalScroll(): number {\n    return this.element.scrollTop;\n  }\n\n  getMaxHorizontalScroll(): number {\n    return this.element.scrollWidth - this.element.clientWidth;\n  }\n\n  getMaxVerticalScroll(): number {\n    return this.element.scrollHeight - this.element.clientHeight;\n  }\n\n  getHorizontalElementScrollOffset(\n    elementToScrollTo: Element,\n    elementToScroll: Element\n  ): number {\n    return (\n      getElementOffset(elementToScrollTo).left -\n      getElementOffset(elementToScroll).left\n    );\n  }\n\n  getVerticalElementScrollOffset(\n    elementToScrollTo: Element,\n    elementToScroll: Element\n  ): number {\n    return (\n      getElementOffset(elementToScrollTo).top -\n      getElementOffset(elementToScroll).top\n    );\n  }\n\n  scrollTo(x: number, y: number) {\n    this.element.scrollLeft = x;\n    this.element.scrollTop = y;\n  }\n}\n\nclass ScrollWindow {\n  element: Window = window;\n\n  getHorizontalScroll(): number {\n    return window.scrollX || document.documentElement.scrollLeft;\n  }\n\n  getVerticalScroll(): number {\n    return window.scrollY || document.documentElement.scrollTop;\n  }\n\n  getMaxHorizontalScroll(): number {\n    return (\n      Math.max(\n        document.body.scrollWidth,\n        document.documentElement.scrollWidth,\n        document.body.offsetWidth,\n        document.documentElement.offsetWidth,\n        document.body.clientWidth,\n        document.documentElement.clientWidth\n      ) - window.innerWidth\n    );\n  }\n\n  getMaxVerticalScroll(): number {\n    return (\n      Math.max(\n        document.body.scrollHeight,\n        document.documentElement.scrollHeight,\n        document.body.offsetHeight,\n        document.documentElement.offsetHeight,\n        document.body.clientHeight,\n        document.documentElement.clientHeight\n      ) - window.innerHeight\n    );\n  }\n\n  getHorizontalElementScrollOffset(elementToScrollTo: Element): number {\n    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n    return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n  }\n\n  getVerticalElementScrollOffset(elementToScrollTo: Element): number {\n    const scrollTop = window.scrollY || document.documentElement.scrollTop;\n    return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n  }\n\n  scrollTo(x: number, y: number) {\n    window.scrollTo(x, y);\n  }\n}\n\n// --------- KEEPING TRACK OF ACTIVE ANIMATIONS\n\ntype ActiveAnimations = {\n  elements: (Window | Element)[];\n  cancelMethods: (() => void)[];\n  add: (element: Element | Window, cancelAnimation: () => void) => void;\n  remove: (element: Element | Window, shouldStop: boolean) => void;\n};\n\nconst activeAnimations: ActiveAnimations = {\n  elements: [],\n  cancelMethods: [],\n\n  add: (element, cancelAnimation) => {\n    activeAnimations.elements.push(element);\n    activeAnimations.cancelMethods.push(cancelAnimation);\n  },\n  remove: (element, shouldStop) => {\n    const index = activeAnimations.elements.indexOf(element);\n\n    if (index > -1) {\n      // Stop animation\n      if (shouldStop) {\n        activeAnimations.cancelMethods[index]();\n      }\n      // Remove it\n      activeAnimations.elements.splice(index, 1);\n      activeAnimations.cancelMethods.splice(index, 1);\n    }\n  },\n};\n\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\n\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n\n// --------- ANIMATE SCROLL TO\n\nconst defaultOptions: IOptions = {\n  cancelOnUserAction: true,\n  easing: (t) => --t * t * t + 1, // easeOutCubic\n  elementToScroll: WINDOW_EXISTS ? window : null, // Check for server side rendering\n  horizontalOffset: 0,\n  maxDuration: 3000,\n  minDuration: 250,\n  speed: 500,\n  verticalOffset: 0,\n};\n\nasync function animateScrollTo(\n  y: number,\n  userOptions?: IUserOptions\n): Promise<boolean>;\nasync function animateScrollTo(\n  coords: TCoords,\n  userOptions?: IUserOptions\n): Promise<boolean>;\nasync function animateScrollTo(\n  scrollToElement: Element,\n  userOptions?: IUserOptions\n): Promise<boolean>;\nasync function animateScrollTo(\n  numberOrCoordsOrElement: number | TCoords | Element,\n  userOptions: IUserOptions = {}\n): Promise<boolean> {\n  // Check for server rendering\n  if (!WINDOW_EXISTS) {\n    // @ts-ignore\n    // If it still gets called on server, return Promise for API consistency\n    return new Promise((resolve: (hasScrolledToPosition: boolean) => void) => {\n      resolve(false); // Returning false on server\n    });\n  } else if (!(window as any).Promise) {\n    throw \"Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill.\";\n  }\n\n  let x: number;\n  let y: number;\n  let scrollToElement: Element;\n  let options: IOptions = {\n    ...defaultOptions,\n    ...userOptions,\n  };\n\n  const isWindow = options.elementToScroll === window;\n  const isElement = !!(options.elementToScroll as Element).nodeName;\n\n  if (!isWindow && !isElement) {\n    throw 'Element to scroll needs to be either window or DOM element.';\n  }\n\n  // Check for \"scroll-behavior: smooth\" as it can break the animation\n  // https://github.com/Stanko/animated-scroll-to/issues/55\n  const scrollBehaviorElement: Element = isWindow\n    ? document.documentElement\n    : (options.elementToScroll as Element);\n  const scrollBehavior = getComputedStyle(\n    scrollBehaviorElement\n  ).getPropertyValue('scroll-behavior');\n\n  if (scrollBehavior === 'smooth') {\n    console.warn(\n      `${scrollBehaviorElement.tagName} has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations`\n    );\n  }\n\n  // Select the correct scrolling interface\n  const elementToScroll = isWindow\n    ? new ScrollWindow()\n    : new ScrollDomElement(options.elementToScroll as Element);\n\n  if (numberOrCoordsOrElement instanceof Element) {\n    scrollToElement = numberOrCoordsOrElement;\n\n    // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n    if (\n      isElement &&\n      (!(options.elementToScroll as Element).contains(scrollToElement) ||\n        (options.elementToScroll as Element).isSameNode(scrollToElement))\n    ) {\n      throw 'options.elementToScroll has to be a parent of scrollToElement';\n    }\n\n    x = elementToScroll.getHorizontalElementScrollOffset(\n      scrollToElement,\n      options.elementToScroll as Element\n    );\n    y = elementToScroll.getVerticalElementScrollOffset(\n      scrollToElement,\n      options.elementToScroll as Element\n    );\n  } else if (typeof numberOrCoordsOrElement === 'number') {\n    x = elementToScroll.getHorizontalScroll();\n    y = numberOrCoordsOrElement;\n  } else if (\n    Array.isArray(numberOrCoordsOrElement) &&\n    numberOrCoordsOrElement.length === 2\n  ) {\n    x =\n      numberOrCoordsOrElement[0] === null\n        ? elementToScroll.getHorizontalScroll()\n        : (numberOrCoordsOrElement[0] as number);\n    y =\n      numberOrCoordsOrElement[1] === null\n        ? elementToScroll.getVerticalScroll()\n        : (numberOrCoordsOrElement[1] as number);\n  } else {\n    // ERROR\n    throw (\n      'Wrong function signature. Check documentation.\\n' +\n      'Available method signatures are:\\n' +\n      '  animateScrollTo(y:number, options)\\n' +\n      '  animateScrollTo([x:number | null, y:number | null], options)\\n' +\n      '  animateScrollTo(scrollToElement:Element, options)'\n    );\n  }\n\n  // Add offsets\n  x += options.horizontalOffset;\n  y += options.verticalOffset;\n\n  // Horizontal scroll distance\n  const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n  const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n\n  // If user specified scroll position is greater than maximum available scroll\n  if (x > maxHorizontalScroll) {\n    x = maxHorizontalScroll;\n  }\n\n  // Calculate distance to scroll\n  const horizontalDistanceToScroll = x - initialHorizontalScroll;\n\n  // Vertical scroll distance distance\n  const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n  const initialVerticalScroll = elementToScroll.getVerticalScroll();\n\n  // If user specified scroll position is greater than maximum available scroll\n  if (y > maxVerticalScroll) {\n    y = maxVerticalScroll;\n  }\n\n  // Calculate distance to scroll\n  const verticalDistanceToScroll = y - initialVerticalScroll;\n\n  // Calculate duration of the scroll\n  const horizontalDuration = Math.abs(\n    Math.round((horizontalDistanceToScroll / 1000) * options.speed)\n  );\n  const verticalDuration = Math.abs(\n    Math.round((verticalDistanceToScroll / 1000) * options.speed)\n  );\n\n  let duration =\n    horizontalDuration > verticalDuration\n      ? horizontalDuration\n      : verticalDuration;\n\n  // Set minimum and maximum duration\n  if (duration < options.minDuration) {\n    duration = options.minDuration;\n  } else if (duration > options.maxDuration) {\n    duration = options.maxDuration;\n  }\n\n  // @ts-ignore\n  return new Promise(\n    (resolve: (hasScrolledToPosition: boolean) => void, reject) => {\n      // Scroll is already in place, nothing to do\n      if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n        // Resolve promise with a boolean hasScrolledToPosition set to true\n        resolve(true);\n      }\n\n      // Cancel existing animation if it is already running on the same element\n      activeAnimations.remove(elementToScroll.element, true);\n\n      // To cancel animation we have to store request animation frame ID\n      let requestID: number;\n\n      // Cancel animation handler\n      const cancelAnimation = () => {\n        removeListeners();\n        cancelAnimationFrame(requestID);\n\n        // Resolve promise with a boolean hasScrolledToPosition set to false\n        resolve(false);\n      };\n\n      // Registering animation so it can be canceled if function\n      // gets called again on the same element\n      activeAnimations.add(elementToScroll.element, cancelAnimation);\n\n      // Prevent user actions handler\n      const preventDefaultHandler = (e: Event) => e.preventDefault();\n\n      const handler = options.cancelOnUserAction\n        ? cancelAnimation\n        : preventDefaultHandler;\n\n      // If animation is not cancelable by the user, we can't use passive events\n      const eventOptions: any = options.cancelOnUserAction\n        ? { passive: true }\n        : { passive: false };\n\n      const events = ['wheel', 'touchstart', 'keydown', 'mousedown'];\n\n      // Function to remove listeners after animation is finished\n      const removeListeners = () => {\n        events.forEach((eventName) => {\n          elementToScroll.element.removeEventListener(\n            eventName,\n            handler,\n            eventOptions\n          );\n        });\n      };\n\n      // Add listeners\n      events.forEach((eventName) => {\n        elementToScroll.element.addEventListener(\n          eventName,\n          handler,\n          eventOptions\n        );\n      });\n\n      // Animation\n      const startingTime = Date.now();\n\n      const step = () => {\n        var timeDiff = Date.now() - startingTime;\n        var t = timeDiff / duration;\n\n        const horizontalScrollPosition = Math.round(\n          initialHorizontalScroll +\n            horizontalDistanceToScroll * options.easing(t)\n        );\n        const verticalScrollPosition = Math.round(\n          initialVerticalScroll + verticalDistanceToScroll * options.easing(t)\n        );\n\n        if (\n          timeDiff < duration &&\n          (horizontalScrollPosition !== x || verticalScrollPosition !== y)\n        ) {\n          // If scroll didn't reach desired position or time is not elapsed\n          // Scroll to a new position\n          elementToScroll.scrollTo(\n            horizontalScrollPosition,\n            verticalScrollPosition\n          );\n\n          // And request a new step\n          requestID = requestAnimationFrame(step);\n        } else {\n          // If the time elapsed or we reached the desired offset\n          // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n          // Clear animation frame to be sure\n          elementToScroll.scrollTo(x, y);\n\n          cancelAnimationFrame(requestID);\n\n          // Remove listeners\n          removeListeners();\n\n          // Remove animation from the active animations coordinator\n          activeAnimations.remove(elementToScroll.element, false);\n\n          // Resolve promise with a boolean hasScrolledToPosition set to true\n          resolve(true);\n        }\n      };\n\n      // Start animating scroll\n      requestID = requestAnimationFrame(step);\n    }\n  );\n}\n\nexport default animateScrollTo;\n", "import animateScrollTo from '../src/index';\n\n(window as any).animateScrollTo = animateScrollTo;\n"],
  "mappings": "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",
  "names": []
}
